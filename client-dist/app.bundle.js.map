{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./client/box/box.js","webpack:///./client/client.js","webpack:///./client/global-funcs.js","webpack:///./client/player/player-air-all-state.js","webpack:///./client/player/player-air-base-state.js","webpack:///./client/player/player-base-state.js","webpack:///./client/player/player-damaged-base-state.js","webpack:///./client/player/player-ground-attack-strong-state.js","webpack:///./client/player/player-ground-attack-weak-state.js","webpack:///./client/player/player-ground-base-state.js","webpack:///./client/player/player-ground-idle-state.js","webpack:///./client/player/player-ground-walk-state.js","webpack:///./client/player/player.js","webpack:///./client/scenes/game-manager-scene.js","webpack:///./client/scenes/my-tileset-scene.js","webpack:///./client/scenes/server-connection-scene.js"],"names":[],"mappings":";QAAA;QACA;QACA;QACA;QACA;;QAEA;QACA;QACA;QACA,QAAQ,oBAAoB;QAC5B;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA,iBAAiB,4BAA4B;QAC7C;QACA;QACA,kBAAkB,2BAA2B;QAC7C;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;;QAEA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;QAEA;QACA;QACA;QACA;QACA,gBAAgB,uBAAuB;QACvC;;;QAGA;QACA;QACA;QACA;;;;;;;;;;;;;ACvJA;AAAA;AAAA;AAA4C;;AAE7B;AACf;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,E;AACA;AACA;AACA;;AAEA;;AAEA,C;;;;;;;;;;;;ACzBA;AAAA;AAAA;AAAA;AAAA;AAA4B;AACiC;;AAE9C;AACf;AACA;AACA;;AAEA;AACA,SAAS,6CAAM;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA,kBAAkB,6CAAM;AACxB,4CAA4C,qEAAgB;AAC5D;AACA;;;;;;AAMA;AACA;;;;;;;;;;;;;;;AC1CA;AAAA;AAAA;;AAEe;AACf;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,gCAAgC;AAChD;;;AAGA;AACA;AACA,oEAAoE,yBAAyB;AAC7F;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,C;;;;;;;;;;;;AC/FA;AAAA;AAAA;AAA4D;;AAE7C,gCAAgC,iEAAkB;AACjE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AChDA;AAAA;AAAA;AAAA;AAAqD;AACY;;AAElD,iCAAiC,6DAAe;AAC/D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B,oEAAqB;AACpD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;AC/BA;AAAA;AAAA;AAA6C;;AAE9B;AACf;AACA;AACA;AACA,yBAAyB,wDAAW;AACpC;;AAEA;AACA;AACA;AACA;AACA;;AAEA,C;;;;;;;;;;;;ACfA;AAAA;AAAA;AAAA;AAAqD;AACa;;AAEnD,qCAAqC,6DAAe;;AAEnE;AACA;AACA,oBAAoB;AACpB;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,oEAAqB;AACpD;AACA;;AAEA;AACA;AACA;AACA;;AAEA,C;;;;;;;;;;;;ACzCA;AAAA;AAAA;AAAA;AAAA;AAAkE;AACA;AACA;;AAElE;AACe,4CAA4C,oEAAqB;AAChF;AACA;AACA;AACA,4BAA4B;AAC5B,0BAA0B;AAC1B,2BAA2B;AAC3B,uBAAuB;;AAEvB,sBAAsB;AACtB,4BAA4B;;AAE5B,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,oEAAqB;AACtD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACvHA;AAAA;AAAA;AAAA;AAAkE;AACA;;;AAGlE;AACe,0CAA0C,oEAAqB;AAC9E;AACA;AACA;AACA,4BAA4B;AAC5B,0BAA0B;AAC1B,2BAA2B;AAC3B,uBAAuB;;AAEvB,sBAAsB;AACtB,4BAA4B;;AAE5B,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,oEAAqB;AACtD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACvHA;AAAA;AAAA;AAAA;AAAqD;AACK;;AAE3C,oCAAoC,6DAAe;AAClE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,+BAA+B,gEAAiB;AAChD;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,C;;;;;;;;;;;;AC3BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAkE;AACA;AACiB;AACH;;AAEjE,oCAAoC,oEAAqB;AACxE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,+BAA+B,oEAAqB;AACpD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,2EAA4B;AAC3D;AACA;AACA;AACA,+BAA+B,6EAA6B;AAC5D;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC/CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAkE;AACA;AACiB;AACH;;AAEjE,oCAAoC,oEAAqB;AACxE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oEAAqB;AACpD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,2EAA4B;AAC3D;AACA;AACA;AACA,+BAA+B,6EAA6B;AAC5D;;;;AAIA;AACA;;AAEA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC9DA;AAAA;AAAA;AAAA;AAAA;AAA4C;AACsB;AACE;;AAEpE;AACe;AACf;AACA;AACA,yBAAyB,wDAAW;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,oB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,oEAAqB;AACxC;;AAEA;AACA;AACA;AACA,kE;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA,wBAAwB,qEAAsB;AAC9C;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;AC7SA;AAAA;AAAA;AAAA;AAAA;AAAkD;AACc;AACpB;;;AAG7B;AACf;AACA;AACA;AACA,yBAAyB,wDAAW;AACpC;;AAEA;AACA;AACA;;AAEA;AACA,4CAA4C,mEAAqB;AACjE;;;AAGA;AACA;AACA;AACA,sB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;;AAGA;;;;;;;;;;;;;;ACjDA;AAAA;AAAA;AAAA;AAAA;AAA4C;AACJ;AACT;;AAEhB;AACf;AACA;;AAEA,yBAAyB,wDAAW;AACpC,oBAAoB,yDAAM;AAC1B,iBAAiB,mDAAG;AACpB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mEAAmE,gCAAgC;AACnG;;;AAGA,+DAA+D,gCAAgC;AAC/F;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gCAAgC,kBAAkB;;AAElD;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sCAAsC,eAAe;;AAErD;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;AAIA;AACA;;;;;;;;;;;;;;;AC9HA;AAAA;AAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,gBAAgB,uBAAuB;AACvC;AACA;AACA;;AAEA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA,qCAAqC,sBAAsB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAmB,+BAA+B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gBAAgB,uBAAuB;AACvC;AACA;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA,O;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA","file":"app.bundle.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t\"app\": 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([\"./client/client.js\",\"vendors\"]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","import GlobalFuncs from \"../global-funcs.js\"\r\n\r\nexport default class Box {\r\n\tconstructor(scene) {\r\n\t\tthis.scene = scene;\r\n\t\tthis.globalfuncs = new GlobalFuncs();\r\n\t\tthis.group = null;\r\n\t}\r\n\r\n\tcreate()\r\n\t{\r\n\t\t//create animations\r\n\t\tthis.globalfuncs.createSceneAnimsFromAseprite(this.scene, \"box\", \"box-json\");\r\n\t\tthis.group = this.scene.physics.add.staticGroup();\r\n\t\tthis.scene.physics.add.collider(this.group, this.scene.layer1);\r\n\t}\r\n\r\n\tspawn(x, y)\r\n\t{\t\t\r\n\t\tvar a = this.group.create(x, y, \"box\");\r\n\t\ta.setScale(0.5, 0.5);\r\n\t\tconsole.log(a);\r\n\r\n\t}\r\n\r\n}","import Phaser from 'phaser';\r\nimport GameManagerScene from './scenes/game-manager-scene.js'\r\n\r\nexport default class Client {\r\n\tconstructor() {\r\n\t\tthis.game = {};\r\n\t\tthis.config = {};\r\n\r\n\t\tthis.config = {\r\n\t\t\ttype: Phaser.AUTO,\r\n\t\t\tbackgroundColor: '#333333',\r\n\t\t\twidth: 256,\r\n\t\t\theight:256,\r\n\t\t\tparent: 'game-div',\r\n\t\t\tpixelArt: true,\r\n\t\t\tphysics: {\r\n\t\t\t\tdefault: 'arcade',\t\t\t\t\r\n\t\t\t\tarcade: {\r\n\t\t\t\t\tdebug: true,\r\n\t\t\t\t\tdebugShowBody: true,\r\n\t\t\t\t\tdebugShowStaticBody: true,\r\n\t\t\t\t\tdebugShowVelocity: true,\r\n\t\t\t\t\tgravity: {\r\n\t\t\t\t\t\ty: 300\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tscale: {\r\n\t\t\t\tzoom:3\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.game = new Phaser.Game(this.config);\r\n\t\tthis.game.scene.add('game-manager-scene', GameManagerScene, true);\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n//feels like a hacky way to start...oh well. Its simple atleast.\r\nvar app = new Client();\r\n\r\n\r\n","var tempGlobalMessages = [];\r\n\r\nexport default class GlobalFuncs {\r\n\tconstructor() {\r\n\t\tthis.tempGlobalMessages = tempGlobalMessages;\r\n\t}\r\n\r\n\t\r\n\t//Helper function to register events to emitters in phaser.\r\n\t//scene - the scene\r\n\t//eventMapping - array of mappings for events\r\n\t// Each mapping needs the following format:\r\n\t// eventMapping = [\r\n\t// {\r\n\t//\t \ttarget: this.load,\r\n\t//\t \tevent: 'progress',\r\n\t//\t \tdelegate: this.loadProgress\r\n\t// },\r\n\t// {}...\r\n\t// ]\r\n\t// \t\ttarget - the event emitter in phaser\r\n\t//\t\tevent - the name of the event\r\n\t//\t\tdelegate - the delegate to call\r\n\r\n\tregisterEvents(scene, eventMapping) {\r\n\t\tfor(var i = 0; i < eventMapping.length; i++)\r\n\t\t{\r\n\t\t\teventMapping[i].target.on(eventMapping[i].event, eventMapping[i].delegate)\r\n\t\t}\r\n\t}\r\n\r\n\t//Helper function to unregister events from emitters in phaser. This is the opposite of GlobalFuncs.registerEvents().\r\n\t//This is to be called in the \"shutdown\" event.\r\n\tunregisterEvents(scene, eventMapping) {\r\n\t\tfor(var i = 0; i < eventMapping.length; i++)\r\n\t\t{\r\n\t\t\teventMapping[i].target.off(eventMapping[i].event, eventMapping[i].delegate)\r\n\t\t}\r\n\t}\r\n\r\n\tcreateSceneAnimsFromAseprite(scene, asepriteSpritesheetKey, asepriteJsonKey) {\r\n\t\t//find the aseprite json file to parse from\r\n\t\tvar json = scene.cache.json.get(asepriteJsonKey);\r\n\t\tvar anims = scene.anims;\r\n\r\n\t\t//parse through the frameTags for the animations and create an animation for each one\r\n\t\tfor(var i = 0; i < json.meta.frameTags.length; i++)\r\n\t\t{\r\n\r\n\r\n\t\t\tvar f = json.meta.frameTags[i];\r\n\t\t\tvar key = asepriteSpritesheetKey + \"-\" + f.name;\r\n\t\t\tvar frames = anims.generateFrameNumbers(asepriteSpritesheetKey, {start: f.from, end: f.to});\r\n\t\t\tvar animObject = {\r\n\t\t\t\tkey: key,\r\n\t\t\t\tframes: frames,\r\n\t\t\t\tframeRate: 24,\r\n\t\t\t\trepeat: -1\r\n\t\t\t}\r\n\r\n\t\t\t//console.log(animObject);\r\n\t\t\tanims.create(animObject);\r\n\t\t}\r\n\t}\r\n\r\n\t//9/10/2020 - This is to fix the arcade sprite when the sprite is created in the update function instead of the create function.\r\n\t//This basically realligns the sprite body's hitbox so it doesn't get out of sync with the sprite game object.\r\n\t//You only need to call this once, and only after you create the sprite with this.scene.add.sprite(...);\r\n\t//This also works with images. \r\n\t//If you need to set the size, scale, and offset of the body on creation, do it after you create the sprite and THEN call this function.\r\n\t/*Ex:\r\n\t\tvar s = this.scene.physics.add.sprite(50, 50, \"spritesheethere\", 0);\r\n\r\n\t\ts.body.setOffset(5, 5);\r\n\t\ts.setScale(2, 1);\r\n\t\ts.body.setSize(10, 19, false);\r\n\r\n\t\tarcadeSpriteFix(s);\r\n\t*/\r\n\tarcadeSpriteFix(arcadeSprite) {\r\n\t\tvar newx = arcadeSprite.x - (0.5 * arcadeSprite.displayWidth) + (arcadeSprite.scaleX * arcadeSprite.body.offset.x);\r\n\t\tvar newy = arcadeSprite.y - (0.5 * arcadeSprite.displayHeight) + (arcadeSprite.scaleY * arcadeSprite.body.offset.y);\r\n\r\n\t\tarcadeSprite.body.position.x = newx;\r\n\t\tarcadeSprite.body.position.y = newy;\r\n\t\tarcadeSprite.body.prev.x = newx;\r\n\t\tarcadeSprite.body.prev.y = newy;\r\n\t\tarcadeSprite.body.prevFrame.x = newx;\r\n\t\tarcadeSprite.body.prevFrame.y = newy;\r\n\t\tarcadeSprite.body.transform.scaleX = arcadeSprite.scaleX;\r\n\t\tarcadeSprite.body.transform.scaleY = arcadeSprite.scaleY;\r\n\t\tarcadeSprite.body.width = Math.floor(arcadeSprite.body.width * arcadeSprite.scaleX);\r\n\t\tarcadeSprite.body.height = Math.floor(arcadeSprite.body.height * arcadeSprite.scaleY);\r\n\t}\r\n\r\n}","import PlayerAirBaseState from \"./player-air-base-state.js\";\r\n\r\nexport default class PlayerAirAllState extends PlayerAirBaseState {\r\n\tconstructor(scene, player) {\r\n\t\tsuper(scene, player);\r\n\t}\r\n\r\n\tenter(timeElapsed, dt) {\r\n\t\tthis.calculateAnimation();\r\n\t\tthis.player.sprite.anims.setTimeScale(8/24);\r\n\t\tsuper.enter(timeElapsed, dt);\r\n\t}\r\n\r\n\tupdate(timeElapsed, dt) {\r\n\r\n\t\tif(this.player.playerController.right.state)\r\n\t\t{\r\n\t\t\tthis.player.sprite.flipX = false;\r\n\t\t\tthis.player.applyWalkForce(1);\r\n\t\t}\r\n\t\telse if(this.player.playerController.left.state)\r\n\t\t{\r\n\t\t\tthis.player.sprite.flipX = true;\r\n\t\t\tthis.player.applyWalkForce(-1);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthis.player.sprite.setVelocityX(0);\r\n\t\t}\r\n\r\n\t\tthis.calculateAnimation();\r\n\t\tsuper.update(timeElapsed, dt);\r\n\t}\r\n\r\n\texit(timeElapsed, dt) {\r\n\t\tsuper.exit(timeElapsed, dt);\r\n\t}\r\n\r\n\tcalculateAnimation() {\r\n\t\t//rising\r\n\t\tif(this.player.sprite.body.velocity.y <= 0)\r\n\t\t{\r\n\t\t\tthis.player.sprite.anims.play(\"slime-rising\");\r\n\t\t}\r\n\t\telse{\r\n\t\t\tthis.player.sprite.anims.play(\"slime-falling\");\r\n\t\t}\r\n\t}\r\n}","import PlayerBaseState from \"./player-base-state.js\";\r\nimport PlayerGroundIdleState from \"./player-ground-idle-state.js\"\r\n\r\nexport default class PlayerAirBaseState extends PlayerBaseState {\r\n\tconstructor(scene, player) {\r\n\t\tsuper(scene, player);\r\n\t}\r\n\r\n\tenter(timeElapsed, dt) {\r\n\t\tsuper.enter(timeElapsed, dt);\r\n\t}\r\n\r\n\tupdate(timeElapsed, dt) {\r\n\t\t//transfer to on ground state\r\n\t\tif(this.player.sprite.body.blocked.down)\r\n\t\t{\r\n\t\t\tthis.player.nextState = new PlayerGroundIdleState(this.scene, this.player);\r\n\t\t}\r\n\r\n\t\t//add jump force\r\n\t\tif(this.player.playerController.jump.state && !this.player.playerController.jump.prevState)\r\n\t\t{\r\n\t\t\tthis.player.applyJumpForce();\r\n\t\t}\r\n\t\t\r\n\t\tsuper.update(timeElapsed, dt);\r\n\t}\r\n\r\n\texit(timeElapsed, dt) {\r\n\t\tsuper.exit(timeElapsed, dt);\r\n\t}\r\n}","import GlobalFuncs from \"../global-funcs.js\";\r\n\r\nexport default class PlayerBaseState {\r\n\tconstructor(scene, player) {\r\n\t\tthis.scene = scene;\r\n\t\tthis.player = player;\r\n\t\tthis.globalfuncs = new GlobalFuncs();\r\n\t}\r\n\r\n\tenter(timeElapsed, dt) {}\r\n\tupdate(timeElapsed, dt) {}\r\n\texit(timeElapsed, dt) {\r\n\t\tthis.player.sprite.anims.setTimeScale(24);\r\n\t}\r\n\r\n}","import PlayerBaseState from \"./player-base-state.js\";\r\nimport PlayerGroundIdleState from \"./player-ground-idle-state.js\";\r\n\r\nexport default class PlayerDamagedBaseState extends PlayerBaseState {\r\n\t\r\n\tconstructor(scene, player) {\r\n\t\tsuper(scene, player);\r\n\t\tthis.timer = 1000; //ms\r\n\t}\r\n\r\n\tenter(timeElapsed, dt) {\r\n\t\tthis.player.sprite.setTint(0xff0000);\r\n\r\n\t\t//play damaged animation here\r\n\t\t\r\n\t\t//temporary. Just judging direction based on sprite direction.\r\n\t\tvar xDir = -1;\r\n\t\tif(this.player.sprite.flipX)\r\n\t\t{\r\n\t\t\txDir = 1;\r\n\t\t}\r\n\r\n\t\tthis.player.applyDamageForce(xDir);\r\n\t\tsuper.enter(timeElapsed, dt);\r\n\t}\r\n\r\n\tupdate(timeElapsed, dt) {\r\n\t\tsuper.update(timeElapsed, dt);\r\n\t\tthis.timer -= dt;\r\n\r\n\t\tif(this.timer <= 0)\r\n\t\t{\r\n\t\t\tthis.player.nextState = new PlayerGroundIdleState(this.scene, this.player);\r\n\t\t}\r\n\t}\r\n\r\n\texit(timeElapsed, dt) {\r\n\t\tthis.player.sprite.clearTint();\r\n\t\tsuper.exit(timeElapsed, dt);\r\n\t}\r\n\t\r\n}","import PlayerGroundBaseState from \"./player-ground-base-state.js\";\r\nimport PlayerGroundWalkState from \"./player-ground-walk-state.js\";\r\nimport PlayerGroundIdleState from \"./player-ground-idle-state.js\";\r\n\r\n//this state is to drive the events AND animation with dt from update\r\nexport default class PlayerGroundAttackStrongState extends PlayerGroundBaseState {\r\n\tconstructor(scene, player) {\r\n\t\tsuper(scene, player);\r\n\t\tthis.sumTime = 0;\r\n\t\tthis.actionFrameStart = 2;  //frame num of animation for start of action\r\n\t\tthis.actionFrameEnd = 3;\t//frame num of animation for end of action\r\n\t\tthis.totalDuration = 500; //total duration of the animation in ms\r\n\t\tthis.totalFrames = 1; //total number of frames in animation\r\n\t\t\r\n\t\tthis.msPerFrame = 1; //calculated duration of each frame in ms\r\n\t\tthis.currentAnimFrame = 0; //current frame of the attack\r\n\r\n\t\tthis.swingState = 0; //0 - swing up. 1 - action. 2 - swing down\r\n\t\tthis.animationDone = false;\r\n\r\n\t\tthis.hitboxWidth = 18 * this.player.sprite.scaleX;\r\n\t\tthis.hitboxHeight = 26 * this.player.sprite.scaleY;\r\n\t\tthis.hitboxOffsetX = 8 * this.player.sprite.scaleX;\r\n\t\tthis.hitboxOffsetY = -2 * this.player.sprite.scaleY;\r\n\t}\r\n\r\n\tenter(timeElapsed, dt) {\r\n\t\tthis.player.sprite.anims.play(\"slime-attackStrong\");\r\n\t\t\r\n\t\tthis.player.sprite.anims.pause(this.player.sprite.anims.currentAnim.frames[this.currentAnimFrame]);\r\n\t\tthis.totalFrames = this.player.sprite.anims.getTotalFrames();\r\n\t\tthis.msPerFrame = this.totalDuration/this.totalFrames;\r\n\t\t\r\n\t\tsuper.enter(timeElapsed, dt);\r\n\t}\r\n\r\n\tupdate(timeElapsed, dt) {\r\n\t\tthis.sumTime += dt;\r\n\t\tif(this.sumTime >= this.msPerFrame)\r\n\t\t{\r\n\t\t\tvar temp = Math.floor(this.sumTime / this.msPerFrame);\r\n\t\t\tthis.sumTime %= this.msPerFrame;\r\n\t\t\tthis.currentAnimFrame += temp;\r\n\t\t\tif(this.currentAnimFrame >= this.totalFrames && this.swingState == 2)\r\n\t\t\t{\r\n\t\t\t\tthis.currentAnimFrame = this.totalFrames - 1;\r\n\t\t\t\tthis.animationDone = true;\r\n\t\t\t}\r\n\t\t\telse if (this.currentAnimFrame >= this.totalFrames)\r\n\t\t\t{\r\n\t\t\t\tthis.currentAnimFrame = this.totalFrames - 1;\r\n\t\t\t}\r\n\t\t\tthis.player.sprite.anims.pause(this.player.sprite.anims.currentAnim.frames[this.currentAnimFrame]);\r\n\t\t}\r\n\r\n\t\tswitch(this.swingState)\r\n\t\t{\r\n\t\t\tcase 0:\r\n\t\t\t\t//enter action\r\n\t\t\t\tif(this.currentAnimFrame >= this.actionFrameStart)\r\n\t\t\t\t{\r\n\t\t\t\t\tthis.currentAnimFrame = this.actionFrameStart;\r\n\t\t\t\t\tthis.player.sprite.anims.pause(this.player.sprite.anims.currentAnim.frames[this.currentAnimFrame]);\r\n\t\t\t\t\tthis.swingState = 1;\r\n\r\n\t\t\t\t\t//create hitbox here\r\n\t\t\t\t\tthis.createHitbox();\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase 1:\r\n\t\t\t\t//make the hitbox follow the player\r\n\t\t\t\tthis.hitbox.x = this.player.sprite.x;\r\n\t\t\t\tthis.hitbox.y = this.player.sprite.y;\r\n\t\t\t\t\r\n\t\t\t\t//exit action\r\n\t\t\t\tif(this.currentAnimFrame >= this.actionFrameEnd)\r\n\t\t\t\t{\r\n\t\t\t\t\tthis.currentAnimFrame = this.actionFrameEnd;\r\n\t\t\t\t\tthis.player.sprite.anims.pause(this.player.sprite.anims.currentAnim.frames[this.currentAnimFrame]);\r\n\t\t\t\t\tthis.swingState = 2;\r\n\r\n\t\t\t\t\t//delete hitbox here\r\n\t\t\t\t\tthis.deleteHitbox();\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\t\tif(this.animationDone)\r\n\t\t\t\t{\r\n\t\t\t\t\tthis.player.sprite.anims.stop();\r\n\t\t\t\t\tthis.player.nextState = new PlayerGroundIdleState(this.scene, this.player)\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tsuper.update(timeElapsed, dt);\r\n\t}\r\n\r\n\texit(timeElapsed, dt) {\r\n\t\tthis.player.sprite.anims.stop();\r\n\t\tthis.deleteHitbox();\r\n\t\tsuper.exit(timeElapsed, dt);\r\n\t}\r\n\r\n\tcreateHitbox() {\r\n\t\tthis.hitbox = this.scene.physics.add.image(this.player.sprite.x, this.player.sprite.y);\r\n\t\tthis.hitbox.body.allowGravity = false;\r\n\t\tthis.hitbox.body.setSize(this.hitboxWidth, this.hitboxHeight, true);\r\n\t\tthis.hitbox.body.setOffset(this.hitbox.body.offset.x + this.hitboxOffsetX, this.hitbox.body.offset.y + this.hitboxOffsetY);\r\n\r\n\t\tthis.globalfuncs.arcadeSpriteFix(this.hitbox);\r\n\t}\r\n\r\n\tdeleteHitbox() {\r\n\t\tif(this.hitbox)\r\n\t\t{\r\n\t\t\tthis.hitbox.destroy();\r\n\t\t\tthis.hitbox = null;\r\n\t\t}\r\n\t}\r\n}","import PlayerGroundBaseState from \"./player-ground-base-state.js\";\r\nimport PlayerGroundIdleState from \"./player-ground-idle-state.js\";\r\n\r\n\r\n//this state is to drive the events AND animation with dt from update\r\nexport default class PlayerGroundAttackWeakState extends PlayerGroundBaseState {\r\n\tconstructor(scene, player) {\r\n\t\tsuper(scene, player);\r\n\t\tthis.sumTime = 0;\r\n\t\tthis.actionFrameStart = 1;  //frame num of animation for start of action\r\n\t\tthis.actionFrameEnd = 3;\t//frame num of animation for end of action\r\n\t\tthis.totalDuration = 500; //total duration of the animation in ms\r\n\t\tthis.totalFrames = 1; //total number of frames in animation\r\n\t\t\r\n\t\tthis.msPerFrame = 1; //calculated duration of each frame in ms\r\n\t\tthis.currentAnimFrame = 0; //current frame of the attack\r\n\r\n\t\tthis.swingState = 0; //0 - swing up. 1 - action. 2 - swing down\r\n\t\tthis.animationDone = false;\r\n\r\n\t\tthis.hitboxWidth = 12 * this.player.sprite.scaleX;\r\n\t\tthis.hitboxHeight = 14 * this.player.sprite.scaleY;\r\n\t\tthis.hitboxOffsetX = 0 * this.player.sprite.scaleX;\r\n\t\tthis.hitboxOffsetY = -12 * this.player.sprite.scaleY;\r\n\t}\r\n\r\n\tenter(timeElapsed, dt) {\r\n\t\tthis.player.sprite.anims.play(\"slime-attackWeak\");\r\n\t\t\r\n\t\tthis.player.sprite.anims.pause(this.player.sprite.anims.currentAnim.frames[this.currentAnimFrame]);\r\n\t\tthis.totalFrames = this.player.sprite.anims.getTotalFrames();\r\n\t\tthis.msPerFrame = this.totalDuration/this.totalFrames;\r\n\r\n\t\tsuper.enter(timeElapsed, dt);\r\n\t}\r\n\r\n\tupdate(timeElapsed, dt) {\r\n\t\tthis.sumTime += dt;\r\n\t\tif(this.sumTime >= this.msPerFrame)\r\n\t\t{\r\n\t\t\tvar temp = Math.floor(this.sumTime / this.msPerFrame);\r\n\t\t\tthis.sumTime %= this.msPerFrame;\r\n\t\t\tthis.currentAnimFrame += temp;\r\n\t\t\tif(this.currentAnimFrame >= this.totalFrames && this.swingState == 2)\r\n\t\t\t{\r\n\t\t\t\tthis.currentAnimFrame = this.totalFrames - 1;\r\n\t\t\t\tthis.animationDone = true;\r\n\t\t\t}\r\n\t\t\telse if (this.currentAnimFrame >= this.totalFrames)\r\n\t\t\t{\r\n\t\t\t\tthis.currentAnimFrame = this.totalFrames - 1;\r\n\t\t\t}\r\n\t\t\tthis.player.sprite.anims.pause(this.player.sprite.anims.currentAnim.frames[this.currentAnimFrame]);\r\n\t\t}\r\n\r\n\t\tswitch(this.swingState)\r\n\t\t{\r\n\t\t\tcase 0:\r\n\t\t\t\t//enter action\r\n\t\t\t\tif(this.currentAnimFrame >= this.actionFrameStart)\r\n\t\t\t\t{\r\n\t\t\t\t\tthis.currentAnimFrame = this.actionFrameStart;\r\n\t\t\t\t\tthis.player.sprite.anims.pause(this.player.sprite.anims.currentAnim.frames[this.currentAnimFrame]);\r\n\t\t\t\t\tthis.swingState = 1;\r\n\r\n\t\t\t\t\t//create hitbox here\r\n\t\t\t\t\tthis.createHitbox();\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase 1:\r\n\t\t\t\t//make the hitbox follow the player\r\n\t\t\t\tthis.hitbox.x = this.player.sprite.x;\r\n\t\t\t\tthis.hitbox.y = this.player.sprite.y;\r\n\r\n\t\t\t\t//exit action\r\n\t\t\t\tif(this.currentAnimFrame >= this.actionFrameEnd)\r\n\t\t\t\t{\r\n\t\t\t\t\tthis.currentAnimFrame = this.actionFrameEnd;\r\n\t\t\t\t\tthis.player.sprite.anims.pause(this.player.sprite.anims.currentAnim.frames[this.currentAnimFrame]);\r\n\t\t\t\t\tthis.swingState = 2;\r\n\r\n\t\t\t\t\t//delete hitbox here\r\n\t\t\t\t\tthis.deleteHitbox();\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\t\tif(this.animationDone)\r\n\t\t\t\t{\r\n\t\t\t\t\tthis.player.nextState = new PlayerGroundIdleState(this.scene, this.player)\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tsuper.update(timeElapsed, dt);\r\n\t}\r\n\r\n\texit(timeElapsed, dt) {\r\n\t\tthis.player.sprite.anims.stop();\r\n\t\tthis.deleteHitbox();\r\n\t\tsuper.exit(timeElapsed, dt);\r\n\t}\r\n\r\n\tcreateHitbox() {\r\n\t\tthis.hitbox = this.scene.physics.add.image(this.player.sprite.x, this.player.sprite.y);\r\n\t\tthis.hitbox.body.allowGravity = false;\r\n\t\tthis.hitbox.body.setSize(this.hitboxWidth, this.hitboxHeight, true);\r\n\t\tthis.hitbox.body.setOffset(this.hitbox.body.offset.x + this.hitboxOffsetX, this.hitbox.body.offset.y + this.hitboxOffsetY);\r\n\r\n\t\tthis.globalfuncs.arcadeSpriteFix(this.hitbox);\r\n\r\n\t}\r\n\r\n\tdeleteHitbox() {\r\n\t\tif(this.hitbox)\r\n\t\t{\r\n\t\t\tthis.hitbox.destroy();\r\n\t\t\tthis.hitbox = null;\r\n\t\t}\r\n\t}\r\n}","import PlayerBaseState from \"./player-base-state.js\";\r\nimport PlayerAirAllState from \"./player-air-all-state.js\";\r\n\r\nexport default class PlayerGroundBaseState extends PlayerBaseState {\r\n\tconstructor(scene, player) {\r\n\t\tsuper(scene, player);\r\n\t}\r\n\r\n\tenter(timeElapsed, dt) {\r\n\t\tsuper.enter(timeElapsed, dt);\r\n\t}\r\n\r\n\tupdate(timeElapsed, dt) {\r\n\t\t\r\n\t\t//transfer to in air state\r\n\t\tif(!this.player.sprite.body.blocked.down)\r\n\t\t{\r\n\t\t\tthis.player.nextState = new PlayerAirAllState(this.scene, this.player);\r\n\t\t}\r\n\r\n\t\tsuper.update(timeElapsed, dt);\r\n\t}\r\n\r\n\texit(timeElapsed, dt) {\r\n\t\tsuper.exit(timeElapsed, dt);\r\n\t}\r\n\t\r\n}","import PlayerGroundBaseState from \"./player-ground-base-state.js\";\r\nimport PlayerGroundWalkState from \"./player-ground-walk-state.js\";\r\nimport PlayerGroundAttackStrongState from \"./player-ground-attack-strong-state.js\";\r\nimport PlayerGroundAttackSWeakState from \"./player-ground-attack-weak-state.js\";\r\n\r\nexport default class PlayerGroundIdleState extends PlayerGroundBaseState {\r\n\tconstructor(scene, player) {\r\n\t\tsuper(scene, player);\r\n\t}\r\n\r\n\tenter(timeElapsed, dt) {\r\n\t\tthis.player.sprite.anims.play(\"slime-idle\");\r\n\t\tthis.player.sprite.anims.setTimeScale(8/24);\r\n\t\tsuper.enter(timeElapsed, dt);\r\n\t}\r\n\r\n\tupdate(timeElapsed, dt) {\r\n\r\n\t\t//walk left/right\r\n\t\tif(this.player.playerController.right.state || this.player.playerController.left.state)\r\n\t\t{\r\n\t\t\tthis.player.nextState = new PlayerGroundWalkState(this.scene, this.player);\r\n\t\t}\r\n\r\n\t\t//add jump force\r\n\t\tif(this.player.playerController.jump.state && !this.player.playerController.jump.prevState)\r\n\t\t{\r\n\t\t\tthis.player.applyJumpForce();\r\n\t\t}\r\n\r\n\t\t//attacks\r\n\t\tif(this.player.playerController.attackWeak.state || this.player.playerController.attackWeak.state)\r\n\t\t{\r\n\t\t\tthis.player.nextState = new PlayerGroundAttackSWeakState(this.scene, this.player);\r\n\t\t}\r\n\t\telse if(this.player.playerController.attackStrong.state || this.player.playerController.attackStrong.state)\r\n\t\t{\r\n\t\t\tthis.player.nextState = new PlayerGroundAttackStrongState(this.scene, this.player);\r\n\t\t}\r\n\r\n\t\tsuper.update(timeElapsed, dt);\r\n\t}\r\n\r\n\texit(timeElapsed, dt) {\r\n\t\tthis.player.sprite.anims.stop();\r\n\t\tsuper.exit(timeElapsed, dt);\r\n\t}\r\n}","import PlayerGroundBaseState from \"./player-ground-base-state.js\";\r\nimport PlayerGroundIdleState from \"./player-ground-idle-state.js\";\r\nimport PlayerGroundAttackStrongState from \"./player-ground-attack-strong-state.js\";\r\nimport PlayerGroundAttackSWeakState from \"./player-ground-attack-weak-state.js\";\r\n\r\nexport default class PlayerGroundWalkState extends PlayerGroundBaseState {\r\n\tconstructor(scene, player) {\r\n\t\tsuper(scene, player);\r\n\t}\r\n\r\n\tenter(timeElapsed, dt) {\r\n\t\tthis.player.sprite.anims.play(\"slime-walk\");\r\n\t\tthis.player.sprite.anims.setTimeScale(8/24);\r\n\t\tsuper.enter(timeElapsed, dt);\r\n\t}\r\n\r\n\tupdate(timeElapsed, dt) {\r\n\t\t\r\n\t\t//walk right\r\n\t\tif(this.player.playerController.right.state)\r\n\t\t{\r\n\t\t\tthis.player.sprite.flipX = false;\r\n\t\t\tthis.player.applyWalkForce(1);\r\n\t\t}\r\n\t\t//walk left\r\n\t\telse if(this.player.playerController.left.state)\r\n\t\t{\r\n\t\t\tthis.player.sprite.flipX = true;\r\n\t\t\tthis.player.applyWalkForce(-1);\r\n\t\t}\r\n\t\t//idle\r\n\t\telse\r\n\t\t{\r\n\t\t\tthis.player.sprite.setVelocityX(0);\r\n\t\t\tthis.player.nextState = new PlayerGroundIdleState(this.scene, this.player);\r\n\t\t}\r\n\r\n\t\t//add jump force\r\n\t\tif(this.player.playerController.jump.state && !this.player.playerController.jump.prevState)\r\n\t\t{\r\n\t\t\tthis.player.applyJumpForce();\r\n\t\t}\r\n\r\n\t\t//attacks\r\n\t\tif(this.player.playerController.attackWeak.state || this.player.playerController.attackWeak.state)\r\n\t\t{\r\n\t\t\tthis.player.nextState = new PlayerGroundAttackSWeakState(this.scene, this.player);\r\n\t\t}\r\n\t\telse if(this.player.playerController.attackStrong.state || this.player.playerController.attackStrong.state)\r\n\t\t{\r\n\t\t\tthis.player.nextState = new PlayerGroundAttackStrongState(this.scene, this.player);\r\n\t\t}\r\n\r\n\t\t\r\n\r\n\t\tsuper.update(timeElapsed, dt);\r\n\t}\r\n\r\n\texit(timeElapsed, dt) {\r\n\t\tthis.player.sprite.anims.stop();\r\n\t\tsuper.exit(timeElapsed, dt);\r\n\t}\r\n}","import GlobalFuncs from \"../global-funcs.js\"\r\nimport PlayerGroundIdleState from \"./player-ground-idle-state.js\";\r\nimport PlayerDamagedBaseState from \"./player-damaged-base-state.js\";\r\n\r\n//the player class\r\nexport default class Player {\r\n\tconstructor(scene) {\r\n\t\tthis.scene = scene;\r\n\t\tthis.globalfuncs = new GlobalFuncs();\r\n\r\n\t\t//mapping of actions to keyboard key codes. Export this to external file and load in on game startup.\r\n\t\tthis.playerInputKeyboardMap = {\r\n\t\t\tleft: 37,\r\n\t\t\tright: 39,\r\n\t\t\tup: 38,\r\n\t\t\tdown: 40,\r\n\t\t\tjump: 90,\r\n\t\t\tattackWeak: 88,\r\n\t\t\tattackStrong: 67,\r\n\t\t\tstart: 13,\r\n\t\t\tselect: 32\r\n\t\t};\r\n\r\n\t\t//mapping of actions to gamepad buttons. Export this to external file and load in on game startup.\r\n\t\tthis.playerInputGamepadMap = {\r\n\t\t\tjump: 'a',\r\n\t\t\tattackWeak: 'x',\r\n\t\t\tattackStrong: 'y',\r\n\t\t\tstart: 'start',\r\n\t\t\tselect: 'select'\r\n\t\t};\r\n\r\n\t\t//The actual controller used to control the player.\r\n\t\tthis.playerController = {};\r\n\r\n\t\t//other variables\r\n\t\tthis.debugCounter = 0;\r\n\r\n\t\tthis.state = null; \r\n\t\tthis.nextState = null;\r\n\r\n\t\tthis.walkSpeed = 100;\r\n\r\n\t\t//player physics variables\r\n\t\tthis.moveVelTarget = 0;\r\n\t\tthis.moveHysteresis = 0.5;\r\n\t\tthis.moveVelVector = {\r\n\t\t\tx: 0,\r\n\t\t\ty: 0\r\n\t\t};\r\n\t\tthis.physVelVectorFinal = {\r\n\t\t\tx: 0,\r\n\t\t\ty: 0\r\n\t\t}\r\n\t\tthis.moveAccMagnitude = 50;\r\n\t\tthis.moveFrictionCoeff = 0.1;\r\n\t\t\r\n\t}\r\n\r\n\r\n\t//this is a seperate function that is called by player states, and we may not want to ALWAYS call it (for example, if the player is damaged, we do not want to call the normal physics)\t\r\n\tapplyPlayerPhysics(dt)\r\n\t{\r\n\r\n\r\n\t\t/////////////////////////////////////////////\r\n\t\t//calculate movement acceleration and speed//\r\n\t\tvar lowerBound = this.moveVelTarget - this.moveHysteresis;\r\n\t\tvar upperBound = this.moveVelTarget + this.moveHysteresis;\r\n\r\n\t\t//determine if the player is within the target + hysteresis. If it is, snap the speed to the target.\r\n\t\tif(this.moveVelVector.x >= lowerBound && this.moveVelVector.x <= upperBound)\r\n\t\t{\r\n\t\t\tthis.moveVelVector.x = this.moveVelTarget;\r\n\t\t}\r\n\t\t//apply acceleration to the direction of the target\r\n\t\telse\r\n\t\t{\r\n\t\t\tvar accDirection = (this.moveVelTarget - this.moveVelVector.x) >= 0 ? 1 : -1;\r\n\t\t\tvar velToAdd = (this.moveAccMagnitude * accDirection * this.moveFrictionCoeff) * dt/1000;\r\n\t\t\tvar velPrediction = this.moveVelVector.x + velToAdd;\r\n\r\n\t\t\t//if the acceleration would cause the velocity to overshoot, snap velocity to the target\r\n\t\t\tif((accDirection > 0 && velPrediction >= lowerBound) || \r\n\t\t\t\t(accDirection < 0 && velPrediction <= upperBound))\r\n\t\t\t{\r\n\t\t\t\tthis.moveVelVector.x = this.moveVelTarget;\r\n\t\t\t}\r\n\t\t\t//if it undershoots, add acceleration like normal\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tthis.moveVelVector.x += velToAdd;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tthis.physVelVectorFinal.x = this.moveVelVector.x;\r\n\r\n\t\t//apply velocities to rigid body\r\n\t\t//rb.velocity = physVelVectorFinal;\r\n\r\n\r\n\r\n\r\n\r\n\t\t//original\r\n\t\t// /////////////////////////////////////////////\r\n\t\t// //calculate movement acceleration and speed//\r\n\t\t// var lowerBound = moveVelTarget - moveHysteresis;\r\n\t\t// var upperBound = moveVelTarget + moveHysteresis;\r\n\t\t\r\n\t\t// //determine if the player is within the target + hysteresis. If it is, snap the speed to the target.\r\n\t\t// if(moveVelVector.x >= lowerBound && moveVelVector.x <= upperBound)\r\n\t\t// {\r\n\t\t// \tmoveVelVector.x = moveVelTarget;\r\n\t\t// }\r\n\t\t// //apply acceleration to the direction of the target\r\n\t\t// else\r\n\t\t// {\r\n\t\t// \tvar accDirection = (moveVelTarget - moveVelVector.x) >= 0 ? 1 : -1;\r\n\t\t// \tvar velToAdd = (moveAccMagnitude * accDirection * moveFrictionCoeff) * dt;\r\n\t\t// \tvar velPrediction = moveVelVector.x + velToAdd;\r\n\r\n\t\t// \t//if the acceleration would cause the velocity to overshoot, snap velocity to the target\r\n\t\t// \tif((accDirection > 0 && velPrediction >= lowerBound) || \r\n\t\t// \t\t(accDirection < 0 && velPrediction <= upperBound))\r\n\t\t// \t{\r\n\t\t// \t\tmoveVelVector.x = moveVelTarget;\r\n\t\t// \t}\r\n\t\t// \t//if it undershoots, add acceleration like normal\r\n\t\t// \telse\r\n\t\t// \t{\r\n\t\t// \t\tmoveVelVector.x += velToAdd;\r\n\t\t// \t}\r\n\t\t// }\r\n\t\t\r\n\t\t// physVelVectorFinal.x = moveVelVector.x;\r\n\t\t// physVelVectorFinal.y = rb.velocity.y;\r\n\r\n\t\t// //apply velocities to rigid body\r\n\t\t// rb.velocity = physVelVectorFinal;\r\n\t}\r\n\r\n\r\n\r\n\tcreate() {\r\n\t\t//create animations\r\n\t\tthis.globalfuncs.createSceneAnimsFromAseprite(this.scene, \"slime\", \"slime-json\");\r\n\r\n\t\t//create sprite\r\n\t\tvar xPos = 175;\r\n\t\tvar yPos = 80;\r\n\r\n\t\tthis.sprite = this.scene.physics.add.sprite(xPos, yPos, \"slime\", 0);\r\n\t\tthis.sprite.label = \"player\";\r\n\t\tthis.sprite.setScale(2, 2);\r\n\t\t\r\n\t\t//controls\r\n\t\t//create a virtual button for the playerController\r\n\t\tfor(var key in this.playerInputKeyboardMap)\r\n\t\t{\r\n\t\t\tvar virtualButton = {\r\n\t\t\t\t\tkeyCode: 0,\r\n\t\t\t\t\tphaserKeyCode: \"\",\r\n\t\t\t\t\tstate: false,\r\n\t\t\t\t\tprevState: false,\r\n\t\t\t\t\tphaserKeyObj: {}\r\n\t\t\t};\r\n\r\n\t\t\t//find the phaserKeyCode (its innefficent I know. I don't care)\r\n\t\t\tfor(var phaserKeyCode in Phaser.Input.Keyboard.KeyCodes)\r\n\t\t\t{\r\n\t\t\t\tif(Phaser.Input.Keyboard.KeyCodes[phaserKeyCode] == this.playerInputKeyboardMap[key])\r\n\t\t\t\t{\r\n\t\t\t\t\tvirtualButton.phaserKeyCode = phaserKeyCode;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvirtualButton.keyCode = this.playerInputKeyboardMap[key];\r\n\t\t\tvirtualButton.phaserKeyObj = this.scene.input.keyboard.addKey(this.playerInputKeyboardMap[key]);\r\n\r\n\t\t\tthis.playerController[key] = virtualButton;\r\n\t\t}\r\n\r\n\t\t//for each virtual button, create a listener to change the virutal button's state\r\n\t\tfor(var key in this.playerController)\r\n\t\t{\r\n\t\t\tthis.scene.input.keyboard.on(\"keydown-\"+this.playerController[key].phaserKeyCode, this.tempDown, this.playerController[key]);\r\n\t\t\tthis.scene.input.keyboard.on(\"keyup-\"+this.playerController[key].phaserKeyCode, this.tempUp, this.playerController[key]);\r\n\t\t}\r\n\r\n\t\t//initial state\r\n\t\tthis.state = new PlayerGroundIdleState(this.scene, this);\r\n\t\tthis.state.enter();\r\n\r\n\t\t//main body collision\r\n\t\tthis.sprite.body.setSize(12, 12)\r\n\t\tthis.sprite.body.setOffset(26, 28);\r\n\t\tthis.scene.physics.add.collider(this.sprite, this.scene.layer1);\t\t\r\n\t\tthis.scene.physics.add.collider(this.sprite, this.scene.box.group, this.onCollideBox, null, this);\r\n\r\n\t\t//other physics stuff\r\n\t\tthis.sprite.setDrag(0, 0);\r\n\t\tthis.frameNum = 0;\r\n\t\t\r\n\t\tconsole.log(this);\r\n\t}\r\n\r\n\t\r\n\ttempDown(e) {\r\n\t\tthis.state = true;\r\n\t}\r\n\r\n\ttempUp(e) {\r\n\t\tthis.state = false;\r\n\t}\r\n\t\r\n\r\n\tupdate(timeElapsed, dt) {\r\n\t\tthis.frameNum++;\r\n\r\n\t\t//testing a movement bug\r\n\t\t// if(this.frameNum == 5)\r\n\t\t// {\r\n\t\t// \tthis.playerController.jump.state = true;\r\n\t\t// }\r\n\t\t// else if(this.frameNum == 46)\r\n\t\t// {\r\n\t\t// \t//this.scene.scene.pause(this.scene.scene.key);\r\n\t\t// \tthis.playerController.right.state = true;\r\n\t\t// }\r\n\t\t// else if(this.frameNum == 49)\r\n\t\t// {\r\n\t\t// \t//this.scene.scene.pause(this.scene.scene.key);\r\n\t\t// \tthis.playerController.right.state = false;\r\n\t\t// }\r\n\t\t// else if(this.frameNum == 70)\r\n\t\t// {\r\n\t\t// \tconsole.log('PAUSSSEE');\r\n\t\t// \t//this.scene.scene.pause(this.scene.scene.key);\r\n\t\t// \tconsole.log(\"jump state: state: %s, prevState: %s\", this.playerController.jump.state, this.playerController.jump.prevState);\r\n\t\t// }\r\n\t\t\r\n\r\n\t\tthis.state.update(timeElapsed, dt);\r\n\r\n\t\t//temporary for testing damage state. Press start to go into damage state.\r\n\t\tif(this.playerController.start.state && !this.playerController.start.prevState)\r\n\t\t{\r\n\t\t\tthis.nextState = new PlayerDamagedBaseState(this.scene, this);\r\n\t\t}\r\n\r\n\r\n\r\n\r\n\r\n\t\t//tsting physics - it works!\r\n\t\t// if(this.frameNum == 10)\r\n\t\t// {\r\n\t\t// \tthis.moveVelTarget = 10;\r\n\t\t// }\r\n\t\t// else if(this.frameNum == 100)\r\n\t\t// {\r\n\t\t// \tthis.moveVelTarget = 0;\r\n\t\t// }\r\n\t\t// this.applyPlayerPhysics(dt);\r\n\t\t// console.log(\"FRAMENUM: %s - physVelVectorFinal.x: %s\", this.frameNum, this.physVelVectorFinal.x);\r\n\r\n\r\n\t\t//update the prevState on the virtual controller for the player\r\n\t\tfor(var key in this.playerController)\r\n\t\t{\r\n\t\t\tthis.playerController[key].prevState = this.playerController[key].state;\r\n\t\t}\r\n\r\n\t\t//change states if needed\r\n\t\tif(this.nextState)\r\n\t\t{\r\n\t\t\tthis.state.exit();\r\n\t\t\tthis.nextState.enter();\r\n\r\n\t\t\tthis.state = this.nextState;\r\n\t\t\tthis.nextState = null;\r\n\t\t}\r\n\t}\r\n\r\n\tapplyJumpForce() {\r\n\t\tthis.sprite.body.setVelocityY(-100);\r\n\t}\r\n\r\n\tapplyWalkForce(xDir) {\r\n\t\tthis.sprite.body.setVelocityX(xDir * this.walkSpeed);\r\n\t}\r\n\r\n\tapplyDamageForce(xDir) {\r\n\t\tthis.sprite.body.setVelocity(xDir * 100, -100);\r\n\t}\r\n\r\n\tpostUpdate(timeElapsed, dt) {\r\n\t\tconsole.log('player post update');\r\n\t}\r\n}\r\n\r\n","import MyTilesetScene from \"./my-tileset-scene.js\"\r\nimport ServerConnectionScene from \"./server-connection-scene.js\"\r\nimport GlobalFuncs from \"../global-funcs.js\"\r\n\r\n\r\nexport default class GameManagerScene extends Phaser.Scene {\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.myMessages = [];\r\n\t\tthis.globalfuncs = new GlobalFuncs();\r\n\t}\r\n\t  \r\n\tcreate() {\r\n\t\t//create other scenes\r\n\t\tconsole.log('adding scenes...');\r\n\r\n\t\t//testing arcade physics\r\n\t\tthis.scene.add('server-connection-scene', ServerConnectionScene);\r\n\t\tthis.scene.start('server-connection-scene');\r\n\r\n\r\n\t\t//some things to press and log stuff when i need to\r\n\t\twindow.addEventListener(\"keyup\", (e) => {\r\n\t\t\t//console.log('keycode:' + e.keyCode);\r\n\t\t\tswitch(e.keyCode) {\t\t\t\t\r\n\t\t\t\tcase 49: //1\r\n\t\t\t\t\tconsole.log('1 clicked.');\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 50: //2\r\n\t\t\t\t\tconsole.log('2 clicked.');\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 51: //3\r\n\t\t\t\t\tconsole.log('3 clicked.');\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 52: //4\r\n\t\t\t\t\tconsole.log('4 clicked.');\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 81: //q\r\n\t\t\t\t\tconsole.log('q clicked.');\r\n\t\t\t\t\tconsole.log(this);\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\t  \r\n\tupdate(timeElapsed, dt) {\r\n\t}\r\n\r\n\r\n}\r\n\r\n","import GlobalFuncs from \"../global-funcs.js\"\r\nimport Player from \"../player/player.js\"\r\nimport Box from \"../box/box.js\"\r\n\r\nexport default class MyTilesetScene extends Phaser.Scene {\r\n\tconstructor(config) {\r\n\t\tsuper(config);\r\n\r\n\t\tthis.globalfuncs = new GlobalFuncs();\r\n\t\tthis.player = new Player(this);\r\n\t\tthis.box = new Box(this);\r\n\t}\r\n\r\n\tinit() {\r\n\t\tconsole.log('init on ' + this.scene.key + ' start');\r\n\t}\r\n\r\n\tpreload() {\r\n\t\tconsole.log('preload on ' + this.scene.key + ' start');\r\n\t\tthis.load.tilemapTiledJSON(\"my-tilemap\", \"assets/tilemaps/my-tilemap.json\");\r\n\t\tthis.load.image(\"my-tileset\", \"assets/tilesets/my-tileset.png\");\r\n\r\n\t\tthis.load.spritesheet(\"slime\", \"assets/spritesheets/slime.png\", {frameWidth: 64, frameHeight: 64});\r\n\t\tthis.load.json(\"slime-json\", \"assets/spritesheets/slime.json\");\r\n\r\n\r\n\t\tthis.load.spritesheet(\"box\", \"assets/spritesheets/box.png\", {frameWidth: 32, frameHeight: 32});\r\n\t\tthis.load.json(\"box-json\", \"assets/spritesheets/box.json\");\r\n\t}\r\n\t  \r\n\tcreate() {\r\n\t\tconsole.log('create on ' + this.scene.key + ' start');\r\n\t\tconsole.log(this);\r\n\t\t//debug grid\r\n\t\tthis.add.grid(0, 0, 1000, 1000, 10, 10, 0x057605);\r\n\r\n\t\t///////////////////////////\r\n\t\t// create world\r\n\t\t///////////////////////////\t\t\r\n\t\t//load tilemap\r\n\t\tthis.map = this.make.tilemap({key: \"my-tilemap\"});\r\n\r\n\t\t//load tileset\r\n\t\tthis.tileset = this.map.addTilesetImage(\"my-tileset\");\r\n\r\n\t\t//create layers\r\n\t\tthis.layer1 = this.map.createStaticLayer(\"Tile Layer 1\", this.tileset, 0, 0);\r\n\t\t//this.layer2 = this.map.createStaticLayer(\"Tile Layer 2\", this.tileset, 0, 0);\r\n\r\n\t\t//set collision for tile layer\r\n\t\tthis.layer1.setCollisionByProperty({collides: true});\r\n\r\n\t\t//add debug colors to tiles\r\n\t\tthis.layer1.renderDebug(this.add.graphics());\r\n\r\n\r\n\t\t///////////////////////////\r\n\t\t// create box\r\n\t\t///////////////////////////\r\n\t\tthis.box.create();\r\n\r\n\t\t//spawn some boxes\r\n\t\t// this.box.spawn(180, 50);\r\n\t\t// this.box.spawn(210, 50);\r\n\r\n\r\n\r\n\t\t///////////////////////////\r\n\t\t// create player\r\n\t\t///////////////////////////\r\n\t\tthis.player.create();\r\n\r\n\r\n\t\t///////////////////////////\r\n\t\t// create camera\r\n\t\t///////////////////////////\r\n\t\t// this.cameraRightBound = 300;\r\n\t\t// this.cameraLeftBound = -50;\r\n\t\t// this.cameraUpBound = -450;\r\n\t\t// this.cameraDownBound = 450;\r\n\r\n\t\t// this.cameraOffsetX = -(this.cameras.main.width / 2);\r\n\t\t// this.cameraOffsetY = -(this.cameras.main.height / 2);\r\n\r\n\t\t// this.cameraRightBoundInner = this.cameraRightBound - this.cameras.main.width;\r\n\t\t// this.cameraLeftBoundInner = this.cameraLeftBound;\r\n\t\t// this.cameraUpBoundInner = this.cameraUpBound;\r\n\t\t// this.cameraDownBoundInner = this.cameraDownBound - this.cameras.main.height;\r\n\t}\r\n\r\n\t  \r\n\tupdate(timeElapsed, dt) {\r\n\r\n\t\tthis.player.update(timeElapsed, dt);\r\n\t\r\n\t\t// var newx = this.player.sprite.x + this.cameraOffsetX;\r\n\t\t// var newy = this.player.sprite.y + this.cameraOffsetY;\r\n\r\n\t\t// //prevents scrolling to the left too much\r\n\t\t// if(newx <= this.cameraLeftBoundInner)\r\n\t\t// {\r\n\t\t// \tnewx = this.cameraLeftBoundInner;\r\n\t\t// }\r\n\t\t// //prevents scrolling to the right too much\r\n\t\t// else if(newx >= this.cameraRightBoundInner)\r\n\t\t// {\r\n\t\t// \tnewx = this.cameraRightBoundInner;\r\n\t\t// }\r\n\r\n\t\t// //prevents scrolling up too much\r\n\t\t// if(newy <= this.cameraUpBoundInner)\r\n\t\t// {\r\n\t\t// \tnewy = this.cameraUpBoundInner;\r\n\t\t// }\r\n\t\t// //prevents scrolling down too much\r\n\t\t// else if(newy >= this.cameraDownBoundInner)\r\n\t\t// {\r\n\t\t// \tnewy = this.cameraDownBoundInner;\r\n\t\t// }\r\n\r\n\t\t// this.cameras.main.scrollX = newx;\r\n\t\t// this.cameras.main.scrollY = newy;\r\n\r\n\r\n\r\n\t}\r\n}\r\n\r\n\r\n","export default class ServerConnectionScene extends Phaser.Scene {\r\n\tconstructor(config) {\r\n\t\tsuper(config);\r\n\t\tthis.ws = null;\r\n\t\tthis.messageSent = false;\r\n\t\tthis.tempLineGraphicsArr = [];\r\n\t\tthis.planckUnitsToPhaserUnitsRatio = 4;\r\n\t\tthis.radiansToDegreesRatio = 180/3.14\r\n\t}\r\n\r\n\tinit() {\r\n\t\tconsole.log('init on ' + this.scene.key + ' start');\r\n\t\tthis.ws = new WebSocket(\"ws://localhost:8080\");\r\n\t\tthis.ws.onmessage = this.onmessage.bind(this);\r\n\t\tconsole.log(this.ws);\r\n\t}\r\n\r\n\tpreload() {\r\n\t\tconsole.log('preload on ' + this.scene.key + ' start');\r\n\t\tthis.load.image(\"my-tileset\", \"assets/tilesets/my-tileset.png\");\r\n\t}\r\n\t  \r\n\tcreate() {\r\n\t\tconsole.log('create on ' + this.scene.key + ' start');\r\n\t\tthis.cameras.main.scrollX = -150;\r\n\t\tthis.cameras.main.scrollY = -150;\r\n\r\n\t\tthis.xAxisGraphic = this.add.graphics();\r\n\t\tthis.xAxisGraphic.lineStyle(1, 0xff0000, 1.0);\r\n\t\tthis.xAxisGraphic.moveTo(0, 0);\r\n\t\tthis.xAxisGraphic.lineTo(10, 0);\r\n\t\tthis.xAxisGraphic.strokePath();\r\n\r\n\t\tthis.yAxisGraphic = this.add.graphics();\r\n\t\tthis.yAxisGraphic.lineStyle(1, 0xff0000, 1.0);\r\n\t\tthis.yAxisGraphic.moveTo(0, 0);\r\n\t\tthis.yAxisGraphic.lineTo(0, 10);\r\n\t\tthis.yAxisGraphic.strokePath();\r\n\r\n\t\t//create functions for the start/stop/restart buttons\r\n\t\twindow.addEventListener(\"start-event\", this.startEvent.bind(this));\r\n\t\twindow.addEventListener(\"stop-event\", this.stopEvent.bind(this));\r\n\t\twindow.addEventListener(\"restart-event\", this.restartEvent.bind(this));\r\n\t}\r\n\r\n\tstartEvent() {\r\n\t\tconsole.log('StartEvent started');\r\n\t\tthis.sendJsonEvent(this.ws, \"start-Event\", \"\");\r\n\t\tconsole.log('StartEvent DONE');\r\n\t}\r\n\r\n\tstopEvent() {\r\n\t\tconsole.log('stopEvent started');\r\n\t\tthis.sendJsonEvent(this.ws, \"stop-Event\", \"\");\r\n\t\tconsole.log('stopEvent DONE');\r\n\t}\r\n\r\n\trestartEvent() {\r\n\t\tconsole.log('restartEvent started');\r\n\t\tthis.sendJsonEvent(this.ws, \"restart-event\", \"\");\r\n\t\tconsole.log('restartEvent DONE');\r\n\t}\r\n\t  \r\n\tupdate(timeElapsed, dt) {\r\n\t\tif(!this.messageSent && this.ws.readyState === WebSocket.OPEN)\r\n\t\t{\r\n\t\t\tconsole.log('now sending message');\r\n\t\t\t//this.ws.send(\"hello from server-connection-scene!\");\r\n\t\t\tthis.sendJsonEvent(this.ws, \"get-world\", \"\");\r\n\t\t\tthis.messageSent = true;\r\n\t\t}\r\n\t}\r\n\r\n\tonmessage(e) {\r\n\t\tvar jsonMsg = this.getJsonEvent(e.data);\r\n\t\tconsole.log('message recieved from server. Event: ' + jsonMsg.event);\r\n\t\tswitch(jsonMsg.event.toLowerCase())\r\n\t\t{\r\n\t\t\tcase \"get-world-response\":\r\n\t\t\t\tconsole.log('got world reponse!');\r\n\t\t\t\tthis.world = JSON.parse(jsonMsg.msg);\r\n\r\n\t\t\t\t//convert phaser units to phaser units\r\n\t\t\t\tthis.convertPlankToPhaserUnits();\r\n\r\n\t\t\t\tconsole.log(this.world);\r\n\t\t\t\tthis.createWorld();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"world-deltas\":\r\n\t\t\t\tconsole.log('got world deltas');\r\n\t\t\t\tvar deltas = JSON.parse(jsonMsg.msg);\r\n\t\t\t\tthis.processDeltas(deltas);\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\tif(jsonMsg.event == \"get-world-response\")\r\n\t\t{\r\n\t\t\t\r\n\t\t}\r\n\t}\r\n\r\n\tsendJsonEvent(socket, event, msg) {\r\n\t\tif(!event)\r\n\t\t{\r\n\t\t\tevent = \"unknown\"\r\n\t\t}\r\n\t\tif(!msg)\r\n\t\t{\r\n\t\t\tmsg = \"\"\r\n\t\t}\r\n\t\t\r\n\t\tvar data = {\r\n\t\t\tevent: event,\r\n\t\t\tmsg: msg\r\n\t\t}\r\n\t\tsocket.send(JSON.stringify(data));\r\n\t}\r\n\r\n\tgetJsonEvent(msg) {\r\n\t\tvar j = {};\r\n\t\tif(!msg)\r\n\t\t{\r\n\t\t\treturn j;\r\n\t\t}\r\n\r\n\t\tj = JSON.parse(msg);\r\n\t\treturn j;\r\n\t}\r\n\r\n\tcreateWorld() {\r\n\t\tconsole.log('creating world now');\r\n\t\t\r\n\t\tfor(var i = 0; i < this.world.length; i++)\r\n\t\t{\r\n\t\t\tvar o = this.world[i];\r\n\t\t\to.planckGraphics = [];\r\n\r\n\t\t\tfor(var j = 0; j < o.fixtures.length; j++)\r\n\t\t\t{\r\n\t\t\t\tvar f = o.fixtures[j];\r\n\t\t\t\tswitch(f.shapeType.toLowerCase())\r\n\t\t\t\t{\r\n\t\t\t\t\tcase \"polygon\":\r\n\t\t\t\t\tcase \"edge\":\r\n\t\t\t\t\t\tvar tempLineGraphics = this.add.graphics();\r\n\r\n\t\t\t\t\t\ttempLineGraphics.lineStyle(1, 0x00ff00, 1);\r\n\t\t\t\t\t\ttempLineGraphics.moveTo(f.vertices[0].x, f.vertices[0].y);\r\n\r\n\t\t\t\t\t\tfor(var v = 1; v < f.vertices.length; v++)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\ttempLineGraphics.lineTo(f.vertices[v].x, f.vertices[v].y);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\ttempLineGraphics.closePath();\r\n\t\t\t\t\t\ttempLineGraphics.strokePath();\r\n\r\n\t\t\t\t\t\ttempLineGraphics.setX(o.x);\r\n\t\t\t\t\t\ttempLineGraphics.setY(o.y);\r\n\r\n\t\t\t\t\t\to.planckGraphics.push(tempLineGraphics);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconsole.log('creating world done');\r\n\t}\r\n\r\n\tprocessDeltas(deltas) {\r\n\t\t//update x, y of all bodies in the world\r\n\t\tfor(var i = 0; i < this.world.length; i++)\r\n\t\t{\r\n\t\t\tvar obj = this.world[i];\r\n\t\t\tvar myDelta = deltas.find((x) => {return x.id == obj.id});\r\n\t\t\tif(myDelta)\r\n\t\t\t{\r\n\t\t\t\tif(obj.id == 4)\r\n\t\t\t\t{\r\n\t\t\t\t\tconsole.log('myDelta x, y: %s, %s', myDelta.x, myDelta.y);\r\n\t\t\t\t\tvar newx = myDelta.x * this.planckUnitsToPhaserUnitsRatio;\r\n\t\t\t\t\tvar newy = myDelta.y * this.planckUnitsToPhaserUnitsRatio * -1;\r\n\t\t\t\t\tvar newa = myDelta.a * -this.radiansToDegreesRatio;\r\n\r\n\t\t\t\t\tconsole.log(obj);\r\n\r\n\t\t\t\t\tfor(var j = 0; j < obj.planckGraphics.length; j++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tobj.planckGraphics[j].setX(newx);\r\n\t\t\t\t\t\tobj.planckGraphics[j].setY(newy);\r\n\t\t\t\t\t\tobj.planckGraphics[j].setAngle(newa);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tconvertPlankToPhaserUnits() {\r\n\t\tconsole.log('converting units now');\r\n\t\t\r\n\t\tfor(var i = 0; i < this.world.length; i++)\r\n\t\t{\r\n\t\t\tvar o = this.world[i];\r\n\t\t\tfor(var j = 0; j < o.fixtures.length; j++)\r\n\t\t\t{\r\n\t\t\t\tvar f = o.fixtures[j];\r\n\t\t\t\tswitch(f.shapeType.toLowerCase())\r\n\t\t\t\t{\r\n\t\t\t\t\tcase \"polygon\":\r\n\t\t\t\t\tcase \"edge\":\r\n\t\t\t\t\t\tfor(var v = 0; v < f.vertices.length; v++)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tf.vertices[v].x = f.vertices[v].x * this.planckUnitsToPhaserUnitsRatio;\r\n\t\t\t\t\t\t\tf.vertices[v].y = f.vertices[v].y * this.planckUnitsToPhaserUnitsRatio * -1;\r\n\t\t\t\t\t\t}\t\t\t\t\t\t\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\to.x = o.x * this.planckUnitsToPhaserUnitsRatio;\r\n\t\t\to.y = o.y * this.planckUnitsToPhaserUnitsRatio * -1;\r\n\t\t}\r\n\r\n\t\tconsole.log('converting units done');\r\n\t}\r\n}\r\n\r\n"],"sourceRoot":""}